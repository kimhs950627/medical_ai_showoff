{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "ab121bc2",
   "metadata": {
    "_cell_guid": "b1076dfc-b9ad-4769-8c92-a6c4dae69d19",
    "_kg_hide-input": true,
    "_uuid": "8f2839f25d086af736a60e9eeb907d3b93b6e0e5",
    "execution": {
     "iopub.execute_input": "2024-04-18T03:57:51.841952Z",
     "iopub.status.busy": "2024-04-18T03:57:51.841581Z",
     "iopub.status.idle": "2024-04-18T03:58:21.258394Z",
     "shell.execute_reply": "2024-04-18T03:58:21.257086Z"
    },
    "papermill": {
     "duration": 29.42698,
     "end_time": "2024-04-18T03:58:21.260833",
     "exception": false,
     "start_time": "2024-04-18T03:57:51.833853",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "2024-04-18 03:57:57.056279: E external/local_xla/xla/stream_executor/cuda/cuda_dnn.cc:9261] Unable to register cuDNN factory: Attempting to register factory for plugin cuDNN when one has already been registered\n",
      "2024-04-18 03:57:57.056424: E external/local_xla/xla/stream_executor/cuda/cuda_fft.cc:607] Unable to register cuFFT factory: Attempting to register factory for plugin cuFFT when one has already been registered\n",
      "2024-04-18 03:57:57.197854: E external/local_xla/xla/stream_executor/cuda/cuda_blas.cc:1515] Unable to register cuBLAS factory: Attempting to register factory for plugin cuBLAS when one has already been registered\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Tensorflow version : 2.15.0\n",
      "Keras version : 3.1.1\n",
      "Running on 1 replicas\n",
      "batch size 32\n"
     ]
    }
   ],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "import random\n",
    "import pydicom\n",
    "\n",
    "from sklearn.manifold import TSNE\n",
    "import re\n",
    "import matplotlib.pyplot as plt\n",
    "import matplotlib.cm as cm\n",
    "seed = 2024\n",
    "\n",
    "import warnings\n",
    "warnings.filterwarnings(\"ignore\")\n",
    "\n",
    "# ML tools \n",
    "\n",
    "import tensorflow as tf\n",
    "import keras\n",
    "import keras_cv\n",
    "import keras_nlp\n",
    "#tf.keras.mixed_precision.set_global_policy('mixed_float16')\n",
    "\n",
    "import cv2\n",
    "from skimage.io import imread\n",
    "keras.utils.set_random_seed(seed)\n",
    "import tensorflow_io as tfio\n",
    "from kaggle_datasets import KaggleDatasets\n",
    "import tensorflow_datasets as tfds\n",
    "import tensorflow_probability as tfp\n",
    "import tensorflow_decision_forests as tfdf\n",
    "\n",
    "print(f\"Tensorflow version : {tf.__version__}\")\n",
    "try:\n",
    "    print(f\"Keras version : {keras.__version__}\")\n",
    "except:\n",
    "    pass\n",
    "\n",
    "from keras import Input, Model, ops\n",
    "from keras.models import load_model\n",
    "\n",
    "from keras.layers import Conv2D, DepthwiseConv2D, Dense, Activation, BatchNormalization, LayerNormalization, MultiHeadAttention, Embedding, Subtract, Add, Multiply, GlobalAveragePooling2D, GlobalAveragePooling1D, LayerNormalization\n",
    "from keras.utils import load_img, img_to_array\n",
    "from keras.applications import *\n",
    "import os\n",
    "os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'\n",
    "from sklearn.model_selection import train_test_split\n",
    "from keras.callbacks import ReduceLROnPlateau, ModelCheckpoint, EarlyStopping\n",
    "from tqdm.notebook import tqdm\n",
    "import wandb\n",
    "from wandb.keras import WandbCallback, WandbModelCheckpoint, WandbMetricsLogger\n",
    "def wandb_config():\n",
    "    from kaggle_secrets import UserSecretsClient\n",
    "    user_secrets = UserSecretsClient()\n",
    "    try:\n",
    "        secret_value_0 = user_secrets.get_secret(\"__gcloud_sdk_auth__\")\n",
    "        secret_value_1 = user_secrets.get_secret(\"huggingface_key\")\n",
    "        secret_value_2 = user_secrets.get_secret(\"wandb_key\")\n",
    "        !wandb login $secret_value_2\n",
    "    except:\n",
    "        secret_value_0 = user_secrets.get_secret(\"huggingface_key\")\n",
    "        secret_value_1 = user_secrets.get_secret(\"wandb_key\")\n",
    "        !wandb login $secret_value_1\n",
    "    \n",
    "\n",
    "res = int(1.5*256)\n",
    "small_res = 64\n",
    "batch_size = 32\n",
    "embed_dims = 768\n",
    "\n",
    "def auto_select_accelerator():\n",
    "    try:\n",
    "        tpu = tf.distribute.cluster_resolver.TPUClusterResolver()\n",
    "        tf.config.experimental_connect_to_cluster(tpu)\n",
    "        tf.tpu.experimental.initialize_tpu_system(tpu)\n",
    "        strategy = tf.distribute.experimental.TPUStrategy(tpu)\n",
    "        print(\"Running on TPU:\", tpu.master())\n",
    "    except ValueError:\n",
    "        tpu = False\n",
    "        strategy = tf.distribute.MirroredStrategy() # for GPU or multi-GPU machines\n",
    "    print(f\"Running on {strategy.num_replicas_in_sync} replicas\")\n",
    "    \n",
    "    return tpu, strategy\n",
    "\n",
    "tpu, strategy = auto_select_accelerator()\n",
    "batch_size = strategy.num_replicas_in_sync * batch_size\n",
    "print('batch size', batch_size)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "ef331df6",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-04-18T03:58:21.274569Z",
     "iopub.status.busy": "2024-04-18T03:58:21.273500Z",
     "iopub.status.idle": "2024-04-18T03:58:21.326226Z",
     "shell.execute_reply": "2024-04-18T03:58:21.325374Z"
    },
    "papermill": {
     "duration": 0.061879,
     "end_time": "2024-04-18T03:58:21.328471",
     "exception": false,
     "start_time": "2024-04-18T03:58:21.266592",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Requirements loaded, keras : v3.1.1, Tensorflow : v2.15.0\n"
     ]
    }
   ],
   "source": [
    "import ssl_module\n",
    "from ssl_module import get_gcvit_configs, get_flops, att_visualize, get_full_model, AttentionPooling, BarlowModel, VICRegModel, Moco, SimSiam, CLIP, SigLIP\n",
    "import nas_ftp_module\n",
    "from nas_ftp_module import upload_file, download_file"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b2cbcd45",
   "metadata": {
    "papermill": {
     "duration": 0.005675,
     "end_time": "2024-04-18T03:58:21.339942",
     "exception": false,
     "start_time": "2024-04-18T03:58:21.334267",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# Data import (with Generator)\n",
    "- 목적 : CXR의 prior knowledge를 SwAV으로 feature map generator에 주입시키기\n",
    "- Bounding box의 information을 사용하지 않음 + External data를 사용하자"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "b5db4415",
   "metadata": {
    "_kg_hide-output": true,
    "execution": {
     "iopub.execute_input": "2024-04-18T03:58:21.354140Z",
     "iopub.status.busy": "2024-04-18T03:58:21.353532Z",
     "iopub.status.idle": "2024-04-18T03:58:22.198798Z",
     "shell.execute_reply": "2024-04-18T03:58:22.197529Z"
    },
    "papermill": {
     "duration": 0.855035,
     "end_time": "2024-04-18T03:58:22.201236",
     "exception": false,
     "start_time": "2024-04-18T03:58:21.346201",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Total training cases for CXR : 18025 cases, Validation case : 553 case\n"
     ]
    }
   ],
   "source": [
    "metainfo_dir = \"/kaggle/input/chexdet-image-and-annotations/ChestXDet_Metainformations/ChestX-Det-Dataset-main\"\n",
    "train_det_dir = \"/kaggle/input/chexdet-image-and-annotations/train_data/train\"\n",
    "val_det_dir = \"/kaggle/input/chexdet-image-and-annotations/test_data/test\"\n",
    "\n",
    "df_det_train = pd.read_json(\"/kaggle/input/chexdet-image-and-annotations/ChestXDet_Metainformations/ChestX-Det-Dataset-main/ChestX_Det_train.json\")\n",
    "df_det_train[\"file_name\"] = [os.path.join(train_det_dir, fname) for fname in df_det_train.file_name.values]\n",
    "df_det_train = df_det_train.loc[:, [\"file_name\"]]\n",
    "\n",
    "df_val = pd.read_json(\"/kaggle/input/chexdet-image-and-annotations/ChestXDet_Metainformations/ChestX-Det-Dataset-main/ChestX_Det_test.json\")\n",
    "df_val[\"file_name\"] = [os.path.join(val_det_dir, fname) for fname in df_val.file_name.values]\n",
    "df_val_cxr = df_val.loc[:, [\"file_name\"]]\n",
    "\n",
    "#\n",
    "ext_dir = \"/kaggle/input/vinbigdata-chest-xray-original-png/train\"\n",
    "dict_ext = {\"file_name\" : [os.path.join(ext_dir, fname) for fname in os.listdir(ext_dir)] }\n",
    "df_ext = pd.DataFrame(dict_ext)\n",
    "df_train_cxr = pd.concat([df_det_train, df_ext], axis = 0)\n",
    "print(f\"Total training cases for CXR : {len(df_train_cxr)} cases, Validation case : {len(df_val_cxr)} case\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e147165b",
   "metadata": {
    "papermill": {
     "duration": 0.005501,
     "end_time": "2024-04-18T03:58:22.212481",
     "exception": false,
     "start_time": "2024-04-18T03:58:22.206980",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "> Deeplesion metainformation dataframe 생성"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "e2c47c18",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-04-18T03:58:22.226375Z",
     "iopub.status.busy": "2024-04-18T03:58:22.225637Z",
     "iopub.status.idle": "2024-04-18T03:58:28.195311Z",
     "shell.execute_reply": "2024-04-18T03:58:28.193051Z"
    },
    "papermill": {
     "duration": 5.980751,
     "end_time": "2024-04-18T03:58:28.199102",
     "exception": false,
     "start_time": "2024-04-18T03:58:22.218351",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "03fe8a7f246b49cbb462b4e13e8f19a7",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "0it [00:00, ?it/s]"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Total training cases of Chest/Abdomen CT : 33200 cases, Validation case : 134 case\n"
     ]
    }
   ],
   "source": [
    "ct_fname = []\n",
    "base_img_dir = '/kaggle/input/nih-deeplesion-subset/minideeplesion'\n",
    "for dirname, _, filenames in tqdm(os.walk(base_img_dir)):\n",
    "    for filename in filenames:\n",
    "        ct_fname.append(os.path.join(dirname, filename))\n",
    "        \n",
    "df_ct_whole = pd.DataFrame({\"file_name\" : ct_fname})\n",
    "\n",
    "df_ct_train, df_ct_val = train_test_split(df_ct_whole, \n",
    "                                         test_size = 134,\n",
    "                                         random_state = seed)\n",
    "print(f\"Total training cases of Chest/Abdomen CT : {len(df_ct_train)} cases, Validation case : {len(df_ct_val)} case\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "370c1201",
   "metadata": {
    "papermill": {
     "duration": 0.00583,
     "end_time": "2024-04-18T03:58:28.212374",
     "exception": false,
     "start_time": "2024-04-18T03:58:28.206544",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "> import RSNA ICH dataset metainformation dataframe"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "0ce5bdc6",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-04-18T03:58:28.226612Z",
     "iopub.status.busy": "2024-04-18T03:58:28.225634Z",
     "iopub.status.idle": "2024-04-18T03:58:28.420775Z",
     "shell.execute_reply": "2024-04-18T03:58:28.419202Z"
    },
    "papermill": {
     "duration": 0.204835,
     "end_time": "2024-04-18T03:58:28.423238",
     "exception": false,
     "start_time": "2024-04-18T03:58:28.218403",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Total training cases of Brain, NonCE CT : 32000 cases, Validation case : 300 case\n"
     ]
    }
   ],
   "source": [
    "dicom_dir = \"/kaggle/input/rsna-intracranial-hemorrhage-detection/rsna-intracranial-hemorrhage-detection/stage_2_train\"\n",
    "df_train_brainct = pd.read_csv(\"/kaggle/input/rsna-ich-detection-metadata/df_train_split.csv\")\n",
    "df_val_brainct = pd.read_csv(\"/kaggle/input/rsna-ich-detection-metadata/df_val_splt.csv\").head(300)\n",
    "\n",
    "for df in [df_train_brainct, df_val_brainct]:\n",
    "    df[\"file_name\"] = [os.path.join(dicom_dir, fname + \".dcm\") for fname in df['SOPInstanceUID']]\n",
    "    \n",
    "print(f\"Total training cases of Brain, NonCE CT : {len(df_train_brainct)} cases, Validation case : {len(df_val_brainct)} case\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "5f233e7b",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-04-18T03:58:28.437849Z",
     "iopub.status.busy": "2024-04-18T03:58:28.437382Z",
     "iopub.status.idle": "2024-04-18T03:58:28.909671Z",
     "shell.execute_reply": "2024-04-18T03:58:28.908454Z"
    },
    "papermill": {
     "duration": 0.482711,
     "end_time": "2024-04-18T03:58:28.912227",
     "exception": false,
     "start_time": "2024-04-18T03:58:28.429516",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Total train cases : 83225, val cases : 987 cases\n"
     ]
    },
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>file_name</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>27863</th>\n",
       "      <td>/kaggle/input/rsna-intracranial-hemorrhage-det...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1222</th>\n",
       "      <td>/kaggle/input/nih-deeplesion-subset/minideeple...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>12077</th>\n",
       "      <td>/kaggle/input/nih-deeplesion-subset/minideeple...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>25883</th>\n",
       "      <td>/kaggle/input/nih-deeplesion-subset/minideeple...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>11373</th>\n",
       "      <td>/kaggle/input/vinbigdata-chest-xray-original-p...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>13095</th>\n",
       "      <td>/kaggle/input/vinbigdata-chest-xray-original-p...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2090</th>\n",
       "      <td>/kaggle/input/nih-deeplesion-subset/minideeple...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>10721</th>\n",
       "      <td>/kaggle/input/vinbigdata-chest-xray-original-p...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1321</th>\n",
       "      <td>/kaggle/input/chexdet-image-and-annotations/tr...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>30151</th>\n",
       "      <td>/kaggle/input/rsna-intracranial-hemorrhage-det...</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "                                               file_name\n",
       "27863  /kaggle/input/rsna-intracranial-hemorrhage-det...\n",
       "1222   /kaggle/input/nih-deeplesion-subset/minideeple...\n",
       "12077  /kaggle/input/nih-deeplesion-subset/minideeple...\n",
       "25883  /kaggle/input/nih-deeplesion-subset/minideeple...\n",
       "11373  /kaggle/input/vinbigdata-chest-xray-original-p...\n",
       "13095  /kaggle/input/vinbigdata-chest-xray-original-p...\n",
       "2090   /kaggle/input/nih-deeplesion-subset/minideeple...\n",
       "10721  /kaggle/input/vinbigdata-chest-xray-original-p...\n",
       "1321   /kaggle/input/chexdet-image-and-annotations/tr...\n",
       "30151  /kaggle/input/rsna-intracranial-hemorrhage-det..."
      ]
     },
     "execution_count": 6,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "df_train = pd.concat([df_ct_train, df_train_cxr, df_train_brainct], axis = 0, join='inner')\n",
    "df_val = pd.concat([df_val_cxr, df_ct_val, df_val_brainct], axis = 0, join='inner')\n",
    "\n",
    "df_train.to_csv(\"df_train_ER_SSL.csv\", index = False)\n",
    "df_val.to_csv(\"df_val_ER_SSL.csv\", index = False)\n",
    "\n",
    "print(f\"Total train cases : {len(df_train)}, val cases : {len(df_val)} cases\")\n",
    "df_train.sample(10)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1918e6f4",
   "metadata": {
    "papermill": {
     "duration": 0.006304,
     "end_time": "2024-04-18T03:58:28.925568",
     "exception": false,
     "start_time": "2024-04-18T03:58:28.919264",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# Building Dataloader in keras-3 style\n",
    "- For SwAV training, consider multi-crop with high-res and low-res"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "94e63f60",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-04-18T03:58:28.940841Z",
     "iopub.status.busy": "2024-04-18T03:58:28.940445Z",
     "iopub.status.idle": "2024-04-18T03:58:28.968944Z",
     "shell.execute_reply": "2024-04-18T03:58:28.967886Z"
    },
    "papermill": {
     "duration": 0.039486,
     "end_time": "2024-04-18T03:58:28.971559",
     "exception": false,
     "start_time": "2024-04-18T03:58:28.932073",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "class ImageDataLoader(keras.utils.Sequence):\n",
    "    def __init__(self, dataframe, x_col, res, batch_size, y_col = None, shuffle = True):\n",
    "        self.df = dataframe\n",
    "        self.x_col = x_col ; self.y_col = y_col\n",
    "        self.res = res\n",
    "        self.batch_size = batch_size\n",
    "        self.shuffle = shuffle\n",
    "        self.on_epoch_end()\n",
    "    def dicom_to_tensor(self, dicom_path):\n",
    "        dataset = pydicom.dcmread(dicom_path)\n",
    "        tensor = np.array(dataset.pixel_array)\n",
    "        slope = dataset.RescaleSlope   # dicom header (Rescale slope)\n",
    "        intercept = dataset.RescaleIntercept   # dicom header (Rescale intercept)\n",
    "        center = dataset.WindowCenter   # dicom header (Window center)\n",
    "        width = dataset.WindowWidth   # dicom header (Window width)\n",
    "\n",
    "        if(type(dataset.WindowCenter) == pydicom.multival.MultiValue):\n",
    "                center = float(dataset.WindowCenter[0])\n",
    "                width = float(dataset.WindowWidth[0])       \n",
    "        else:    \n",
    "                center = float(dataset.WindowCenter)\n",
    "                width = float(dataset.WindowWidth)\n",
    "\n",
    "        tensor = slope*tensor + intercept\n",
    "        lbound, ubound = center - 0.5*width, center + 0.5*width\n",
    "        tensor[np.where(tensor < lbound)] = lbound\n",
    "        tensor[np.where(tensor > ubound)] = ubound\n",
    "        tensor = tf.image.resize(tensor[:,:,tf.newaxis], [self.res,self.res]) #HU unit\n",
    "        if tf.shape(tensor)[-1] == 1 :#gray\n",
    "            tensor = tf.image.grayscale_to_rgb(tensor)\n",
    "            \n",
    "        tensor = (tensor - tf.reduce_min(tensor)) / (tf.reduce_max(tensor) - tf.reduce_min(tensor) + 1e-4) #HU unit to Uint8\n",
    "        tensor = tensor*255.0\n",
    "        try:\n",
    "            del dataset\n",
    "        except:\n",
    "            pass\n",
    "        print(f\"Dicom tensor shape : {ops.shape(tensor)}\")\n",
    "        return tensor\n",
    "    \n",
    "    def image_to_tensor(self, path):\n",
    "        if path.split(\".\")[-1] == \"dcm\":\n",
    "            return self.dicom_to_tensor(path)\n",
    "        \n",
    "        if \"minideeplesion\" in str(path).split(\"/\"):\n",
    "            image = imread(path).astype(np.float32)-32768\n",
    "            image = tf.image.resize(image, [self.res, self.res])\n",
    "            print(f\"deepLesion tensor shape : {ops.shape(image)}\")\n",
    "            image = tf.clip_by_value(image, -750.0, 700.0)\n",
    "            image = (image - tf.reduce_min(image))/(tf.reduce_max(image) - tf.reduce_min(image) + 1e-3)\n",
    "            image = image * 255.0\n",
    "            \n",
    "        else:           \n",
    "            image = load_img(path, target_size = [self.res, self.res])\n",
    "            image = img_to_array(image)\n",
    "            print(f\"other tensor shape : {ops.shape(image)}\")\n",
    "        if tf.shape(image)[-1] == 1 :#gray\n",
    "            image = tf.image.grayscale_to_rgb(image)\n",
    "            #image = np.array(image)\n",
    "            \n",
    "\n",
    "        return image\n",
    "        \n",
    "    def on_epoch_end(self):\n",
    "        self.indexes = np.arange(len(self.df))\n",
    "        if self.shuffle:\n",
    "            np.random.shuffle(self.indexes)\n",
    "            \n",
    "    def __len__(self):\n",
    "        return int(np.floor(len(self.df) / self.batch_size))\n",
    "    \n",
    "    def __data_generation(self, img_name):\n",
    "        ## path를 받아 img화 및 token화 하여 실제로 Feeding할 데이터를 반환\n",
    "        X = []\n",
    "        for i, fname in enumerate(img_name):\n",
    "            img = self.image_to_tensor(fname)\n",
    "            img = tf.convert_to_tensor(img)\n",
    "            img = tf.cast(img, tf.uint8)\n",
    "            X.append(img)\n",
    "        \n",
    "        return X\n",
    "        \n",
    "                \n",
    "    def __getitem__(self, index):\n",
    "        indexes = self.indexes[index * self.batch_size : (index + 1) * self.batch_size]\n",
    "        \n",
    "        img_name = [self.df.iloc[k].loc[self.x_col] for k in indexes]\n",
    "        \n",
    "        X = self.__data_generation(img_name)\n",
    "        #X = np.array(X).reshape([-1, self.res, self.res, 3])\n",
    "        return X\n",
    "    \n",
    "def get_train_gen():\n",
    "    return ImageDataLoader(df_train, x_col = \"file_name\",\n",
    "                         res = res, batch_size = batch_size)\n",
    "\n",
    "def get_val_gen():\n",
    "    return ImageDataLoader(df_val, x_col = \"file_name\",\n",
    "                         res = res, batch_size = batch_size)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "d8f867be",
   "metadata": {
    "_kg_hide-input": true,
    "_kg_hide-output": true,
    "execution": {
     "iopub.execute_input": "2024-04-18T03:58:28.987208Z",
     "iopub.status.busy": "2024-04-18T03:58:28.986694Z",
     "iopub.status.idle": "2024-04-18T03:58:29.205332Z",
     "shell.execute_reply": "2024-04-18T03:58:29.204061Z"
    },
    "papermill": {
     "duration": 0.229819,
     "end_time": "2024-04-18T03:58:29.208182",
     "exception": false,
     "start_time": "2024-04-18T03:58:28.978363",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Original\n"
     ]
    }
   ],
   "source": [
    "train_ds = tf.data.Dataset.from_generator(get_train_gen, (tf.uint8), output_shapes = (batch_size, res, res,3) ).ignore_errors().prefetch(tf.data.AUTOTUNE).repeat()\n",
    "val_ds = tf.data.Dataset.from_generator(get_val_gen, (tf.uint8), output_shapes = (batch_size, res, res,3) ).ignore_errors().prefetch(tf.data.AUTOTUNE).repeat()\n",
    "print(\"Original\")\n",
    "for img in train_ds.take(1):\n",
    "    for i in img:\n",
    "        plt.imshow(i)\n",
    "        plt.colorbar()\n",
    "        plt.show()"
   ]
  }
 ],
 "metadata": {
  "kaggle": {
   "accelerator": "none",
   "dataSources": [
    {
     "databundleVersionId": 1188070,
     "datasetId": 654585,
     "sourceId": 13451,
     "sourceType": "competition"
    },
    {
     "databundleVersionId": 8031839,
     "datasetId": 4616374,
     "sourceId": 7923692,
     "sourceType": "datasetVersion"
    },
    {
     "databundleVersionId": 4864291,
     "datasetId": 2727590,
     "sourceId": 4800870,
     "sourceType": "datasetVersion"
    },
    {
     "databundleVersionId": 60763,
     "datasetId": 38326,
     "sourceId": 58333,
     "sourceType": "datasetVersion"
    },
    {
     "databundleVersionId": 4792279,
     "datasetId": 2683088,
     "sourceId": 4729375,
     "sourceType": "datasetVersion"
    },
    {
     "databundleVersionId": 1989350,
     "datasetId": 1164135,
     "sourceId": 1950595,
     "sourceType": "datasetVersion"
    },
    {
     "sourceId": 169421886,
     "sourceType": "kernelVersion"
    },
    {
     "sourceId": 171616877,
     "sourceType": "kernelVersion"
    }
   ],
   "isGpuEnabled": false,
   "isInternetEnabled": true,
   "language": "python",
   "sourceType": "notebook"
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.13"
  },
  "papermill": {
   "default_parameters": {},
   "duration": 44.181548,
   "end_time": "2024-04-18T03:58:32.829419",
   "environment_variables": {},
   "exception": null,
   "input_path": "__notebook__.ipynb",
   "output_path": "__notebook__.ipynb",
   "parameters": {},
   "start_time": "2024-04-18T03:57:48.647871",
   "version": "2.5.0"
  },
  "widgets": {
   "application/vnd.jupyter.widget-state+json": {
    "state": {
     "03fe8a7f246b49cbb462b4e13e8f19a7": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "1.5.0",
      "model_name": "HBoxModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "1.5.0",
       "_model_name": "HBoxModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "1.5.0",
       "_view_name": "HBoxView",
       "box_style": "",
       "children": [
        "IPY_MODEL_3b9020469abf46fa90b02d662e4c2117",
        "IPY_MODEL_f198bb79001b493aa04ec9bf4fb962f3",
        "IPY_MODEL_676bfd9d5b8c4ba7ba8f6f64013f5a57"
       ],
       "layout": "IPY_MODEL_ef7bfd19034144dda5b0078cd15e0a94"
      }
     },
     "3b9020469abf46fa90b02d662e4c2117": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "1.5.0",
      "model_name": "HTMLModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "1.5.0",
       "_model_name": "HTMLModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "1.5.0",
       "_view_name": "HTMLView",
       "description": "",
       "description_tooltip": null,
       "layout": "IPY_MODEL_ce95070ad48e484497e34b96c8d92a3e",
       "placeholder": "​",
       "style": "IPY_MODEL_f1b10aa1bfba4f2dab7bfa012a861aae",
       "value": ""
      }
     },
     "676bfd9d5b8c4ba7ba8f6f64013f5a57": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "1.5.0",
      "model_name": "HTMLModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "1.5.0",
       "_model_name": "HTMLModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "1.5.0",
       "_view_name": "HTMLView",
       "description": "",
       "description_tooltip": null,
       "layout": "IPY_MODEL_77e2dc0e45a941e287df2d6d6a06a01c",
       "placeholder": "​",
       "style": "IPY_MODEL_a5377eafa6454d7dae1197b26eb85ad5",
       "value": " 672/? [00:05&lt;00:00, 132.37it/s]"
      }
     },
     "77e2dc0e45a941e287df2d6d6a06a01c": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "1.2.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "1.2.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "1.2.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "overflow_x": null,
       "overflow_y": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "a0dd3378936f4a4ea37797d947d58d65": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "1.2.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "1.2.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "1.2.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "overflow_x": null,
       "overflow_y": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": "20px"
      }
     },
     "a5377eafa6454d7dae1197b26eb85ad5": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "1.5.0",
      "model_name": "DescriptionStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "1.5.0",
       "_model_name": "DescriptionStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "1.2.0",
       "_view_name": "StyleView",
       "description_width": ""
      }
     },
     "ce95070ad48e484497e34b96c8d92a3e": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "1.2.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "1.2.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "1.2.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "overflow_x": null,
       "overflow_y": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "ef7bfd19034144dda5b0078cd15e0a94": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "1.2.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "1.2.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "1.2.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "overflow_x": null,
       "overflow_y": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "f198bb79001b493aa04ec9bf4fb962f3": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "1.5.0",
      "model_name": "FloatProgressModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "1.5.0",
       "_model_name": "FloatProgressModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "1.5.0",
       "_view_name": "ProgressView",
       "bar_style": "success",
       "description": "",
       "description_tooltip": null,
       "layout": "IPY_MODEL_a0dd3378936f4a4ea37797d947d58d65",
       "max": 1.0,
       "min": 0.0,
       "orientation": "horizontal",
       "style": "IPY_MODEL_f94726964f4c497aaa89de6858f06d5e",
       "value": 1.0
      }
     },
     "f1b10aa1bfba4f2dab7bfa012a861aae": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "1.5.0",
      "model_name": "DescriptionStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "1.5.0",
       "_model_name": "DescriptionStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "1.2.0",
       "_view_name": "StyleView",
       "description_width": ""
      }
     },
     "f94726964f4c497aaa89de6858f06d5e": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "1.5.0",
      "model_name": "ProgressStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "1.5.0",
       "_model_name": "ProgressStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "1.2.0",
       "_view_name": "StyleView",
       "bar_color": null,
       "description_width": ""
      }
     }
    },
    "version_major": 2,
    "version_minor": 0
   }
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
